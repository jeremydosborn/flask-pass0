<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sign in</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }

    .container { width: 100%; max-width: 440px; }

    .card {
      background: white;
      padding: 48px;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,.1);
      border: 1px solid #e5e5e5;
    }

    .header { margin-bottom: 40px; text-align: center; }

    h1 {
      font-size: 28px;
      font-weight: 600;
      margin: 0 0 8px 0;
      color: #1a1a1a;
      letter-spacing: -0.5px;
    }

    .subtitle {
      color: #666;
      font-size: 15px;
      line-height: 1.5;
      margin: 0;
    }

    input {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    input:focus { outline: none; border-color: #1a1a1a; }

    button {
      width: 100%;
      padding: 16px 24px;
      font-size: 16px;
      font-weight: 600;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #1a1a1a;
      color: white;
    }

    button:hover { background: #333; }
    button:active { background: #000; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .msg {
      margin-top: 24px;
      padding: 16px 20px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.5;
      border: 1px solid;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .error { background: #fafafa; color: #333; border-color: #ccc; }
    .success { background: #1a1a1a; color: white; border-color: #1a1a1a; }
    .hidden { display: none; }

    .features {
      margin-top: 40px;
      padding-top: 32px;
      border-top: 1px solid #e5e5e5;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
    }

    .feature { text-align: center; }
    .feature-title { font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 4px; }
    .feature-desc { font-size: 13px; color: #666; line-height: 1.4; }

    @media (max-width: 768px) {
      .features { grid-template-columns: 1fr; gap: 16px; }
      .card { padding: 32px 24px; }
      h1 { font-size: 24px; }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="card">
    <div class="header">
      <h1>Sign in</h1>
      <p class="subtitle">Use your passkey to authenticate securely</p>
    </div>

    <input
      type="text"
      id="username"
      autocomplete="username webauthn"
      placeholder="Click to select passkey..."
    >

    <button id="registerBtn">Create new passkey</button>

    <div id="msg" class="msg hidden"></div>

    <div class="features">
      <div class="feature">
        <div class="feature-title">No passwords</div>
        <div class="feature-desc">Nothing to remember or type</div>
      </div>
      <div class="feature">
        <div class="feature-title">Biometric</div>
        <div class="feature-desc">Face ID or Touch ID</div>
      </div>
      <div class="feature">
        <div class="feature-title">Secure</div>
        <div class="feature-desc">Phishing-resistant</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------------- Helpers ---------------- */

function showMessage(text, type = "error") {
  const el = document.getElementById("msg");
  el.textContent = text;
  el.className = `msg ${type}`;
  el.classList.remove("hidden");
}

function hideMessage() {
  document.getElementById("msg").classList.add("hidden");
}

/* Base64url helpers */
function b64urlToBuf(v) {
  const pad = "=".repeat((4 - v.length % 4) % 4);
  const b64 = (v + pad).replace(/-/g, "+").replace(/_/g, "/");
  const bin = atob(b64);
  const buf = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
  return buf.buffer;
}

function bufToB64url(buf) {
  const bytes = new Uint8Array(buf);
  let bin = "";
  for (const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

function isLikelyInactivePasskeyError(msg) {
  const m = String(msg || "").toLowerCase();
  return (
    m.includes("not found") ||
    m.includes("unknown credential") ||
    m.includes("unknown passkey") ||
    (m.includes("credential") && m.includes("not") && m.includes("recognized")) ||
    (m.includes("passkey") && m.includes("not") && m.includes("recognized"))
  );
}

/* ---------------- Registration ---------------- */

async function registerPasskey() {
  hideMessage();

  try {
    const res = await fetch("/auth/passkey/register/options", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({})
    });
    const opts = await res.json();
    if (opts.error) throw new Error(opts.error);

    opts.challenge = b64urlToBuf(opts.challenge);
    opts.user.id = b64urlToBuf(opts.user.id);

    opts.authenticatorSelection = {
      authenticatorAttachment: "platform",
      requireResidentKey: true,
      residentKey: "required",
      userVerification: "required"
    };

    opts.pubKeyCredParams = [
      { type: "public-key", alg: -7 },
      { type: "public-key", alg: -257 }
    ];

    const cred = await navigator.credentials.create({ publicKey: opts });

    const payload = {
      id: cred.id,
      rawId: bufToB64url(cred.rawId),
      type: cred.type,
      response: {
        clientDataJSON: bufToB64url(cred.response.clientDataJSON),
        attestationObject: bufToB64url(cred.response.attestationObject)
      }
    };

    const verify = await fetch("/auth/passkey/register/verify", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ credential: payload })
    });

    const result = await verify.json().catch(() => ({}));
    if (!verify.ok || !result.success) {
      throw new Error(result.error || "Registration failed");
    }

    showMessage("Passkey created successfully", "success");
    setTimeout(() => (window.location = "/"), 800);

  } catch (err) {
    if (err && err.name === "NotAllowedError") {
      showMessage("Passkey creation cancelled", "error");
    } else {
      showMessage((err && err.message) || "Could not create passkey", "error");
    }
  }
}

document.getElementById("registerBtn").onclick = () => registerPasskey();

/* ---------------- Conditional UI Login (re-armable) ---------------- */

let conditionalAbort = null;
let conditionalInFlight = false;

function abortConditionalUI() {
  try {
    if (conditionalAbort) conditionalAbort.abort();
  } catch (_) {}
  conditionalAbort = null;
  conditionalInFlight = false;
}

async function armConditionalUI() {
  try {
    if (conditionalInFlight) return;

    const available = await PublicKeyCredential.isConditionalMediationAvailable();
    if (!available) return;

    // Abort any prior pending request to avoid "stuck" conditional UI state
    abortConditionalUI();

    conditionalAbort = new AbortController();
    conditionalInFlight = true;

    const res = await fetch("/auth/passkey/login/options", { method: "POST" });
    const opts = await res.json();
    if (opts.error) throw new Error(opts.error);

    opts.challenge = b64urlToBuf(opts.challenge);

    const cred = await navigator.credentials.get({
      publicKey: opts,
      mediation: "conditional",
      signal: conditionalAbort.signal
    });

    // resolved successfully
    conditionalInFlight = false;
    conditionalAbort = null;

    const payload = {
      id: cred.id,
      rawId: bufToB64url(cred.rawId),
      type: cred.type,
      response: {
        clientDataJSON: bufToB64url(cred.response.clientDataJSON),
        authenticatorData: bufToB64url(cred.response.authenticatorData),
        signature: bufToB64url(cred.response.signature),
        userHandle: cred.response.userHandle ? bufToB64url(cred.response.userHandle) : null
      }
    };

    const verify = await fetch("/auth/passkey/login/verify", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ credential: payload })
    });

    const result = await verify.json().catch(() => ({}));

    if (verify.ok && result.success) {
      showMessage("Signed in successfully", "success");
      setTimeout(() => (window.location = "/"), 800);
      return;
    }

    const serverMsg = result.error || "Authentication failed";
    const friendly = isLikelyInactivePasskeyError(serverMsg)
      ? "This passkey is no longer active for this app (it may have been rotated/revoked). Please create a new passkey and consider deleting the passkey from your local device."
      : serverMsg;

    showMessage(friendly, "error");

    // Re-arm so the textbox continues to show passkeys after an error
    setTimeout(() => {
      armConditionalUI();
    }, 250);

  } catch (err) {
    conditionalInFlight = false;
    conditionalAbort = null;

    // User canceled/dismissed picker or we aborted: no UI needed
    if (err && (err.name === "NotAllowedError" || err.name === "AbortError")) return;

    console.log("Conditional UI error:", err);
    // Optional: showMessage((err && err.message) || "Passkey sign-in failed", "error");
  }
}

/* Hook the input to user gestures (most reliable way to show passkey picker) */
const usernameEl = document.getElementById("username");
usernameEl.addEventListener("focus", () => armConditionalUI());
usernameEl.addEventListener("click", () => armConditionalUI());

// Initial arm (may not show until user gesture, but harmless)
armConditionalUI();
</script>

</body>
</html>
